# План работы по созданию веб-сервера и контейнера сервлетов

## Функционал веб-сервера

### 1. Написать простой веб-сервер на ServerSocket
- **Создать базовый веб-сервер**
  - Создать класс `WebServer`, который будет слушать на определенном порту и принимать соединения.
  - Реализовать метод `start()`, который будет открывать `ServerSocket` и ожидать подключения клиентов.
- **Добавить чтение настроек из yml**
  - Использовать библиотеку для работы с YAML файлами, например, SnakeYAML.
  - Написать метод `loadConfiguration()`, который будет читать настройки из yml файла.
  - Пример настройки: порт сервера, корневая директория.
- **Добавить установку порта из VMoptions**
  - Реализовать возможность установки порта через параметры запуска JVM, например, `-Dport=8080`.
  - В методе `start()`, если параметр передан, использовать его для установки порта.

### 2. Добавить многопоточную обработку запросов
- **Реализовать многопоточность**
  - Использовать пул потоков (например, `Executors.newFixedThreadPool()`) для обработки входящих соединений.
  - Создать класс `ClientHandler`, который будет реализовывать `Runnable` и обрабатывать запросы клиентов.

### 3. Реализовать простой парсер HTTP
- **Создать класс `HttpRequestParser`**
  - Написать метод `parse(InputStream input)` для чтения данных из `InputStream` и создания объекта `HttpRequest`.
  - Реализовать парсинг первой строки запроса (метод, путь, версия).
  - Реализовать парсинг заголовков и тела запроса.
- **Добавить использование ThreadLocal для парсинга запроса**
  - Использовать `ThreadLocal` для хранения текущего парсера запроса в потоке, чтобы избежать проблем с многопоточностью.

### 4. Реализовать классы для работы с HTTP
- **Создать класс `HttpRequest`**
  - Создать поля для хранения метода (GET, POST и т.д.), пути, версии, заголовков и тела запроса.
  - Написать геттеры и сеттеры для всех полей.
- **Создать класс `HttpResponse`**
  - Создать поля для хранения статуса (200, 404 и т.д.), заголовков и тела ответа.
  - Написать методы для формирования строки HTTP-ответа, например, `toString()` для преобразования ответа в строку.
  - Реализовать методы для добавления заголовков и установки тела ответа.

### 5. Передать поступивший запрос в контейнер сервлетов
- **Интегрировать контейнер сервлетов**
  - Создать метод `dispatchRequest(HttpRequest request, HttpResponse response)` в классе `WebServer`, который будет передавать обработанный запрос в контейнер сервлетов.

## Функционал контейнера сервлетов

### 6. Реализовать функционал контейнера сервлетов
- **Описать базовые классы**
  - Создать базовые классы для контейнера сервлетов, такие как `Servlet`, `HttpServlet`, `ServletRequest`, `ServletResponse`.
  - Реализовать интерфейс `Servlet`, который будет иметь методы `init()`, `service()`, `destroy()`.
  - Создать абстрактный класс `HttpServlet`, который будет реализовывать интерфейс `Servlet` и добавлять методы для обработки HTTP-методов (doGet, doPost и т.д.).
- **Добавить ServletContext**
  - Реализовать класс `ServletContext` для хранения общих данных, доступных всем сервлетам (например, инициализационные параметры).
  - Реализовать методы для добавления и получения атрибутов.
- **Реализовать автоматическую регистрацию сервлетов в контейнере**
  - Создать класс `ServletContainer`, который будет хранить карту сопоставления путей запросов с сервлетами.
  - Написать метод `registerServlet(String path, Servlet servlet)` для регистрации сервлетов.
  - Добавить механизм для автоматической регистрации сервлетов (например, через чтение конфигурационного файла или сканирование пакетов).
  - Реализовать автоматическую регистрацию методов сервлетов как доступных путей.
- **Добавить обработку поступивших запросов**
  - В классе `ServletContainer` реализовать метод `handleRequest(HttpRequest request, HttpResponse response)`.
  - В методе `handleRequest` сопоставлять путь запроса с зарегистрированными сервлетами и вызывать соответствующий метод сервлета (doGet, doPost и т.д.).
  - Обрабатывать случаи, когда запрашиваемый путь не зарегистрирован (возвращать статус 404).

## Дополнительные шаги

### 7. Централизованное логирование и обработка ошибок
- **Создать интерфейс `InvocationHandler`**
  - Реализовать класс `ServletInvocationHandler` для перехвата вызовов методов сервлетов.
  - Написать логирование начала и окончания выполнения методов.
  - Написать обработку и логирование ошибок.
- **Создать класс `ProxyFactory`**
  - Написать метод для создания прокси-объектов для сервлетов.
- **Обновить `ServletContainer` для использования прокси**
  - Обернуть сервлеты в прокси при регистрации.

### 8. Документация и комментарии
- **Создать документацию**
  - Написать документацию для всех классов и методов.
  - Добавить комментарии в коде для упрощения понимания и поддержки кода в будущем.

### 9. Тестирование и отладка
- **Провести тестирование и отладку**
  - Написать тестовые сервлеты и проверить работу сервера.
  - Написать логирование и обработку ошибок для проверки корректности работы прокси.
  - Провести тестирование многопоточности и корректной обработки запросов.

## Пример использования: Создание сервиса для работы с пользователями по REST

### 10. Создать сервис для работы с пользователями
- **Создать базовый сервлет**
  - Создать класс `UserServlet`, наследующий `HttpServlet`.
  - Реализовать методы doGet, doPost, doPut и doDelete для обработки соответствующих HTTP-запросов.
- **Реализовать методы сервлета**
  - **Get**
    - Написать код для получения списка пользователей или конкретного пользователя по ID.
  - **Post**
    - Написать код для создания нового пользователя.
  - **Put**
    - Написать код для обновления существующего пользователя.
  - **Delete**
    - Написать код для удаления пользователя.
- **Регистрация сервлета**
  - Добавить регистрацию `UserServlet` в контейнер сервлетов.
  - Обеспечить, чтобы методы сервлета автоматически регистрировались как доступные пути для запросов.

        